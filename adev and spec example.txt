    def get_spectrum(self):
        """
        Returns the single sided amplitude spectrum of the data
        """
        logger.info("In function: " + inspect.stack()[0][3])
        print (str(dt.datetime.now()) + '\t' + 'Performing amplitude spectrum analysis')
        self.freq_spectral =    []
        self.psa_spectral =     []
        self.freq_mystat =      []
        self.psa_mystat =       []
        mywindow_spectral =     []
        norm_spectral =         []
        norm_mystat =           []

        for i, j, k in zip(self.ratio, self.ignore, self.tbp):
            ####################################################################
            """
            Ali's code
            """
            # create the window function
#           mywindow_mystat = mystat.hann(1, len(i) - j)
            mywindow_mystat = mystat.hann(float(k), (len(i)-j)*float(k))
            # find the window normalization factor
            norm_mystat.append(mystat.norm_window(mywindow_mystat))
            # get the psa
#            print (len(i[j:]), len(mywindow_mystat))
            freq_mystat, mypsa_mystat = mystat.fft(1./(float(k)), np.array(i[j:]), np.array(mywindow_mystat))
            # append the arrays
            self.freq_mystat.append(freq_mystat)
            self.psa_mystat.append(mypsa_mystat)

    def get_adev(self):
        """
        Returns the allan deviation and the error on the adev
        """
        logger.info("In function: " + inspect.stack()[0][3])
        tau_time = []
        self.tau_time = []
        self.tau = []
        self.adev = []
        self.adev_err = []
        if self.overlap == 1:
            print (str(dt.datetime.now()) + '\t' + 'Performing overlapping AVAR, All tau')
            for i, j, k in zip(self.ratio, self.ignore, self.tbp):
                # for tau = 2^N default
    #                tau, avar, err =  mystat.AllanVariance(i[j:])
    #                tau, avar, err = mystat.adev(i[j:], 1)
                # for all tau
    #                tau, avar, err = mystat.AllanVariance(i[j:], \
    #                                 map(int, np.linspace(1, len(i[j:])/2, len(i[j:])/2)))
                tau, adev, err = mystat.adev(i[j:], 1, list(map(int, np.linspace(1, len(i[j:])//2, len(i[j:])//2))))
                self.tau.append(tau)
                self.adev.append(adev)
                self.adev_err.append(err)
                for tt in tau:
                    tau_time.append(tt*k)
                self.tau_time.append(tau_time)
                tau_time = []
        if self.overlap == 0:
            print (str(dt.datetime.now()) + '\t' + 'Performing non overlapping AVAR, All tau')
            for i, j, k in zip(self.ratio, self.ignore, self.tbp):
                # for tau = 2^N default
    #                tau, avar, err =  mystat.AllanVariance(i[j:])
    #                tau, avar, err = mystat.adev(i[j:], 1)
                # for all tau
    #                tau, avar, err = mystat.AllanVariance(i[j:], \
                tau, adev, err = mystat.adev(i[j:], 0, list(map(int, np.linspace(1, len(i[j:])//2, len(i[j:])//2))))
                self.tau.append(tau)
                self.adev.append(adev)
                self.adev_err.append(err)
                # tau = 2^N, non overlapping
    #                tau, adev, err = mystat.adev(i[j:], 0, None)
                for tt in tau:
                    tau_time.append(tt*k)
                self.tau_time.append(tau_time)
                tau_time = []
#        print (len(self.tau), len(self.tau_time), len(self.adev), len(self.adev_err))
        return self.tau, self.tau_time, self.adev, self.adev_err